diff --git a/pytest.ini b/pytest.ini
new file mode 100644
index 0000000..d34c996
--- /dev/null
+++ b/pytest.ini
@@ -0,0 +1,4 @@
+[pytest]
+pythonpath = src
+testpaths = testing
+addopts = -v -s
\ No newline at end of file
diff --git a/src/products/__init__.py b/src/products/__init__.py
index 23001dc..d1ad6d5 100644
--- a/src/products/__init__.py
+++ b/src/products/__init__.py
@@ -1 +1,2 @@
-from .routes import products_bp
\ No newline at end of file
+from .routes import products_bp
+from .service import ProductService
\ No newline at end of file
diff --git a/src/products/routes.py b/src/products/routes.py
index 5d07083..7291afb 100644
--- a/src/products/routes.py
+++ b/src/products/routes.py
@@ -1,5 +1,5 @@
-from flask import Blueprint, jsonify, request
-from .service import list_products, create_product
+from flask import Blueprint, request, current_app
+# from .service import list_products, create_product
 
 products_bp = Blueprint("products", __name__, url_prefix="/products")
 
@@ -8,7 +8,7 @@ def get_products():
     """
     GET /products returns a list of products.
     """
-    return jsonify(list_products()), 200
+    return current_app.products_service.list_products()
 
 @products_bp.post("")
 def post_product():
@@ -16,4 +16,4 @@ def post_product():
     POST /products adds the new product to the db,
     and returns the new product.
     """
-    return jsonify(create_product(request.get_json())), 201
\ No newline at end of file
+    return current_app.products_service.create_product(request.get_json())
\ No newline at end of file
diff --git a/src/products/service.py b/src/products/service.py
index 09f7d88..53ee2e3 100644
--- a/src/products/service.py
+++ b/src/products/service.py
@@ -1,76 +1,146 @@
-from db import db, Product
-
-def list_products() -> list[dict]:
-    """
-    Retrieve all products from the database.
-
-    Queries the Product model to fetch all product records and returns a list of dictionaries,
-    where each dictionary contains the product's 'id', 'name', and 'price'.
-
-    Returns:
-        list[dict]: A list of dictionaries representing products.
-                    Example:
-                    [
-                        {"id": 1, "name": "Chrome Toaster", "price": 100},
-                        {"id": 2, "name": "Copper Kettle", "price": 49.99},
-                        {"id": 3, "name": "Mixing Bowl", "price": 20}
-                    ]
-    """
-    return [{"id": p.id, "name": p.name, "price": p.price} for p in Product.query.all()]
-
-def create_product(data: dict) -> dict:
-    """
-    Create a new product using the provided data.
-
-    This function validates the input data to ensure that it contains the required 'name' and 'price' keys 
-    with proper types. On successful validation, it creates a new Product instance, adds it to the database, 
-    and commits the transaction. It returns a dictionary representation of the newly created product.
-    
-    If the input data fails validation, a ValueError is raised and caught, and the function returns a tuple 
-    containing an error dictionary and a 400 status code.
-
-    Args:
-        data (dict): A dictionary containing the product details. Must include:
-                     - 'name' (str): The name of the product.
-                     - 'price' (float or int): The price of the product.
-
-    Returns:
-        dict: A dictionary with the new product's details on success.
-              Example: {"id": 4, "name": "Microwave", "price": 200}
-        tuple: In case of a validation error, returns a tuple with an error message and HTTP status code 400.
-               Example: ({"error": "Request must include name and price."}, 400)
-    """
-    try:
-        validate_post_request(data)
-        new_product = Product(name = data["name"], price=data["price"])
-        db.session.add(new_product)
-        db.session.commit()
-        return {"id": new_product.id, "name": new_product.name, "price": new_product.price}
-    except (ValueError, TypeError) as e:
-        return {"error":str(e)}, 400
-
-def validate_post_request(data: dict):
-    """
-    Validate the input data for creating a product.
-
-    Ensures that the provided dictionary is not empty and contains both the 'name' and 'price' keys.
-    Additionally, it checks that the 'name' is a string and the 'price' is either an int or a float.
-    
-    Raises:
-        ValueError: If the data is empty, missing required keys, or invalid.
-                   - Missing keys: "Request must include name and price."
-                   - Invalid value: "'price' must be > 0."
-        TypeError: If the data values are not of the correct data types.
-                   - Incorrect type for 'name': "'name' must be of type string."
-                   - Incorrect type for 'price': "'price' must be of type float or int."
-    Args:
-        data (dict): The input dictionary to be validated.
-    """
-    if not data or not ({'name', 'price'} <= data.keys()):
-        raise ValueError('Request must include name and price.')
-    if type(data['name']) is not str:
-        raise TypeError("'name' must be of type string.")
-    if type(data['price']) not in [float, int]:
-        raise TypeError("'price' must be of type float or int.")
-    if data["price"] <= 0:
-        raise ValueError("'price' must be > 0.")
\ No newline at end of file
+# from db import db, Product
+from flask import jsonify
+
+class ProductService:
+    def __init__(self, db, product_model):
+        self.db = db
+        self.Product = product_model
+
+    def list_products(self) -> list[dict]:
+        """
+        Retrieve all products from the database.
+
+        Queries the Product model to fetch all product records and returns a list of dictionaries,
+        where each dictionary contains the product's 'id', 'name', and 'price'.
+
+        Returns:
+            list[dict]: A list of dictionaries representing products.
+                        Example:
+                        [
+                            {"id": 1, "name": "Chrome Toaster", "price": 100},
+                            {"id": 2, "name": "Copper Kettle", "price": 49.99},
+                            {"id": 3, "name": "Mixing Bowl", "price": 20}
+                        ]
+        """
+        try:
+            product_list = self.Product.query.all()
+            self.validate_product_list(product_list)
+            return jsonify(self.transform_product_list(product_list)), 200
+        except (ValueError, TypeError) as e:
+            return jsonify({"error": str(e)}), 404
+
+    def transform_product_list(self, products: list) -> list[dict]:
+        """
+        Transform the list of Product instances into a list of dictionaries.
+
+        Args:
+            products (list[Product]): The list of Product instances to be transformed.
+
+        Returns:
+            list[dict]: A list of dictionaries representing the products.
+                        Example:
+                        [
+                            {"id": 1, "name": "Chrome Toaster", "price": 100},
+                            {"id": 2, "name": "Copper Kettle", "price": 49.99},
+                            {"id": 3, "name": "Mixing Bowl", "price": 20}
+                        ]
+        """
+        return [{"id": p.id, "name": p.name, "price": p.price} for p in products]
+
+
+    def validate_product_list(self, products: list) -> None:
+        """
+        Validate the list of products.
+
+        Ensures that the provided list is not empty, contains only Product instances, 
+        and that each Product instance has valid 'id', 'name', and 'price' fields 
+        with the correct data types.
+
+        Raises:
+            ValueError: If the list is empty or if any Product instance is missing required fields.
+                    - Empty list: "No products found."
+                    - Missing fields: "Product must contain: id, name, and price fields."
+            TypeError: If any Product instance is not of type Product or has fields with incorrect types.
+                    - Non-Product instance: "One or more of the returned products are not of type <Product>."
+                    - Incorrect 'id' type: "Product id must be of type int."
+                    - Incorrect 'name' type: "Product name must be of type 'str'."
+                    - Incorrect 'price' type: "Product price must be of type 'float'."
+
+        Args:
+            products (list[Product]): The list of Product instances to be validated.
+        """
+        if not products:
+            raise ValueError("No products found.")
+        if not all(type(p) is self.Product for p in products):
+            raise TypeError("One or more of the returned products are not of type <Product>.")
+        if not all(p.id and p.name and p.price for p in products):
+            raise ValueError("Product must contain: id, name, and price fields.")
+        if not all(type(p.id) is int for p in products):
+            raise TypeError("Product id must be of type int.")
+        if not all(type(p.name) is str for p in products):
+            raise TypeError("Product name must be of type 'str'.")
+        if not all(type(p.price) is float for p in products):
+            raise TypeError("Product price must be of type 'float'.")
+
+    def create_product(self, data: dict) -> dict:
+        """
+        Create a new product using the provided data.
+
+        This function validates the input data to ensure that it contains the required 'name' and 'price' keys 
+        with proper types. On successful validation, it creates a new Product instance, adds it to the database, 
+        and commits the transaction. It returns a dictionary representation of the newly created product.
+        
+        If the input data fails validation, a ValueError is raised and caught, and the function returns a tuple 
+        containing an error dictionary and a 400 status code.
+
+        Args:
+            data (dict): A dictionary containing the product details. Must include:
+                        - 'name' (str): The name of the product.
+                        - 'price' (float or int): The price of the product.
+
+        Returns:
+            dict: A dictionary with the new product's details on success.
+                Example: {"id": 4, "name": "Microwave", "price": 200}
+            tuple: In case of a validation error, returns a tuple with an error message and HTTP status code 400.
+                Example: ({"error": "Request must include name and price."}, 400)
+        """
+        try:
+            self.validate_post_request(data)
+            new_product = self.Product(name = data["name"], price=data["price"])
+            self.db.session.add(new_product)
+            self.db.session.commit()
+            return jsonify({"id": new_product.id, "name": new_product.name, "price": new_product.price}), 201
+        except (ValueError, TypeError) as e:
+            return jsonify({"error":str(e)}), 422
+
+    def validate_post_request(self, data: dict) -> None:
+        """
+        Validate the input data for creating a product.
+
+        Ensures that the provided dictionary is not empty and contains both the 'name' and 'price' keys.
+        Additionally, it checks that the 'name' is a string and the 'price' is either an int or a float.
+        
+        Raises:
+            ValueError: If the data is empty, missing required keys, or invalid.
+                    - Missing keys: "Request must include name and price."
+                    - Invalid value: "'price' must be > 0."
+            TypeError: If the data values are not of the correct data types.
+                    - Incorrect type for 'name': "'name' must be of type string."
+                    - Incorrect type for 'price': "'price' must be of type float or int."
+        Args:
+            data (dict): The input dictionary to be validated.
+        """
+        if not data or not ({'name', 'price'} <= data.keys()):
+            raise ValueError('Request must include name and price.')
+        if len(data.keys()) > 2:
+            raise ValueError("Request must only include name and price.")
+        if type(data['name']) is not str:
+            raise TypeError("'name' must be of type string.")
+        if data["name"] == "":
+            raise ValueError("'name' must not be empty.")
+        if type(data['price']) is not float:
+            raise TypeError("'price' must be of type float or int.")
+        if data["price"] <= 0:
+            raise ValueError("'price' must be > 0.")
+        if len(str(data["price"]).split(".")[1]) > 2:
+            raise ValueError("'price' must have at most 2 decimal places.")
\ No newline at end of file
diff --git a/src/sales/__init__.py b/src/sales/__init__.py
index 938a042..b6bdc4b 100644
--- a/src/sales/__init__.py
+++ b/src/sales/__init__.py
@@ -1 +1,2 @@
-from .routes import sales_bp
\ No newline at end of file
+from .routes import sales_bp
+from .service import SalesService
\ No newline at end of file
diff --git a/src/sales/routes.py b/src/sales/routes.py
index 9290013..fe220fc 100644
--- a/src/sales/routes.py
+++ b/src/sales/routes.py
@@ -1,5 +1,4 @@
-from flask import request, Blueprint, jsonify
-from .service import process_sale
+from flask import request, Blueprint, current_app
 
 sales_bp = Blueprint("sales", __name__, url_prefix="/sales")
 
@@ -8,7 +7,4 @@ def make_sale():
     """
     POST /sales processes sale of line-items included in request.
     """
-    try:
-        return jsonify(process_sale(request.get_json())), 200
-    except (ValueError, TypeError) as e:
-        return jsonify({"error": str(e)}), 400
\ No newline at end of file
+    return current_app.sales_service.process_sale(request.get_json())
\ No newline at end of file
diff --git a/src/sales/service.py b/src/sales/service.py
index 7e62ba7..3119c85 100644
--- a/src/sales/service.py
+++ b/src/sales/service.py
@@ -1,126 +1,134 @@
-from db import Product, db
+from flask import jsonify
+class SalesService:
 
-def process_sale(data: dict) -> dict:
-    """
-    Process a sale by validating the request, processing each line item,
-    applying a discount, and calculating the total sale price.
-    
-    Args:
-        data (dict): A dictionary containing the sale request. It must include:
-            - "line_items": A list of line item dictionaries, each with "id" and "quantity".
-            - "discount": An integer representing the flat discount for the sale.
-    Returns:
-        dict: A dictionary containing:
-            - "line_items": A list of processed line items with calculated prices and discounts.
-            - "total_sale_price": The sum of the prices for all line items after discount.
-    Raises:
-        ValueError or TypeError: If the sales request is invalid.
-    """
-    valid_sales_request(data)
-    processed_line_items = [process_line_item(item) for item in data.get("line_items")]
-    discount = data.get("discount", 0)
-    processed_line_items = apply_discount(processed_line_items, discount)
-    return {
-        "line_items": processed_line_items,
-        "total_sale_price": sum(item["price"] for item in processed_line_items)
-    }
+    def __init__(self, db, product_model):
+        self.db = db
+        self.Product = product_model
 
-def apply_discount(line_items: list[dict], total_discount: int) -> list[dict]:
-    """
-    Distribute a flat discount evenly across all line items. The discount is
-    spread proportionally by item count, with any rounding differences adjusted
-    in the last item.
-    
-    Args:
-        line_items (list): A list of dictionaries, each representing a line item.
-            Each line item contains an id, quantity and price.
-        total_discount (int or float): The total discount amount to be applied.
-    Returns:
-        list: The list of line items updated with a new key "discount" indicating
-              the discount amount applied to each item.
-    """
-    accumulated_discount = 0
-    num_items = len(line_items)
-    for i in range(num_items):
-        if i < num_items-1:
-            item_discount = round((total_discount/num_items), 2)
-            accumulated_discount += item_discount
-        else:
-            item_discount = round(total_discount - accumulated_discount, 2)
-        line_items[i]["discount"] = item_discount
-    return line_items
+    def process_sale(self, data: dict) -> dict:
+        """
+        Process a sale by validating the request, processing each line item,
+        applying a discount, and calculating the total sale price.
+        
+        Args:
+            data (dict): A dictionary containing the sale request. It must include:
+                - "line_items": A list of line item dictionaries, each with "id" and "quantity".
+                - "discount": An integer representing the flat discount for the sale.
+        Returns:
+            dict: A dictionary containing:
+                - "line_items": A list of processed line items with calculated prices and discounts.
+                - "total_sale_price": The sum of the prices for all line items after discount.
+        Raises:
+            ValueError or TypeError: If the sales request is invalid.
+        """
+        try:
+            self.valid_sales_request(data)
+            processed_line_items = [self.process_line_item(item) for item in data.get("line_items")]
+            discount = data.get("discount", 0)
+            processed_line_items = self.apply_discount(processed_line_items, discount)
+            return jsonify({
+                "line_items": processed_line_items,
+                "total_sale_price": sum(item["price"] for item in processed_line_items)
+            }), 200
+        except (ValueError, TypeError) as e:
+            return jsonify({"error": str(e)}), 422
 
-def process_line_item(item: dict) -> dict:
-    """
-    Process a single line item by validating the input, looking up the product,
-    and calculating the total price for the given quantity.
-    
-    Args:
-        item (dict): A dictionary with the keys "id" (product ID) and "quantity".
-    Returns:
-        dict: A dictionary representing the processed line item, including:
-            - "id": The product ID.
-            - "quantity": The quantity purchased.
-            - "price": The total price calculated as quantity * product price.
-    Raises:
-        TypeError: If the product ID or quantity is not an integer.
-        ValueError: If the quantity is not positive or the product is not found.
-    """
-    product_id = item.get("id")
-    quantity = item.get("quantity")
+    def apply_discount(self, line_items: list[dict], total_discount: int) -> list[dict]:
+        """
+        Distribute a flat discount evenly across all line items. The discount is
+        spread proportionally by item count, with any rounding differences adjusted
+        in the last item.
+        
+        Args:
+            line_items (list): A list of dictionaries, each representing a line item.
+                Each line item contains an id, quantity and price.
+            total_discount (int or float): The total discount amount to be applied.
+        Returns:
+            list: The list of line items updated with a new key "discount" indicating
+                the discount amount applied to each item.
+        """
+        accumulated_discount = 0
+        num_items = len(line_items)
+        for i in range(num_items):
+            if i < num_items-1:
+                item_discount = round((total_discount/num_items), 2)
+                accumulated_discount += item_discount
+            else:
+                item_discount = round(total_discount - accumulated_discount, 2)
+            line_items[i]["discount"] = item_discount
+        return line_items
 
-    if type(product_id) is not int or type(quantity) is not int:
-        raise TypeError("A product's ID and quantity must be integers.")
-    if quantity <= 0:
-        raise ValueError("Each product must have a positive purchase quantity.")
-    
-    product = product_lookup(product_id)
-    item_total = item["quantity"]*product["price"]
-    
-    return {
-        "id": product_id, 
-        "quantity": quantity, 
-        "price": item_total
-        }
+    def process_line_item(self, item: dict) -> dict:
+        """
+        Process a single line item by validating the input, looking up the product,
+        and calculating the total price for the given quantity.
+        
+        Args:
+            item (dict): A dictionary with the keys "id" (product ID) and "quantity".
+        Returns:
+            dict: A dictionary representing the processed line item, including:
+                - "id": The product ID.
+                - "quantity": The quantity purchased.
+                - "price": The total price calculated as quantity * product price.
+        Raises:
+            TypeError: If the product ID or quantity is not an integer.
+            ValueError: If the quantity is not positive or the product is not found.
+        """
+        product_id = item.get("id")
+        quantity = item.get("quantity")
 
-def product_lookup(product_id: int) -> dict:
-    """
-    Look up a product in the catalog by its ID.
+        if type(product_id) is not int or type(quantity) is not int:
+            raise TypeError("A product's ID and quantity must be integers.")
+        if quantity <= 0:
+            raise ValueError("Each product must have a positive purchase quantity.")
+        
+        product = self.product_lookup(product_id)
+        item_total = item["quantity"]*product["price"]
+        
+        return {
+            "id": product_id, 
+            "quantity": quantity, 
+            "price": item_total
+            }
 
-    Args:
-        product_id (int): The unique identifier of the product.
-    Returns:
-        dict: The product details containing "name" and "price".
-    Raises:
-        ValueError: If no product with the given ID is found.
-    """
-    product = db.session.get(Product, product_id)
-    if not product:
-        raise ValueError(f"Product with id {product_id} not found.")
-    return {"name" : product.name, "price" : product.price}
-    
-def valid_sales_request(data: dict):
-    """
-    Validate the sales request data to ensure all required fields are present
-    and of the correct type.
+    def product_lookup(self, product_id: int) -> dict:
+        """
+        Look up a product in the catalog by its ID.
 
-    Args:
-        data (dict): The sales request data which must include:
-            - "line_items": A list of line items.
-            - "discount": An integer representing the discount amount.
-    Raises:
-        ValueError: If required fields are missing or if the list of line items is empty.
-        TypeError: If "discount" is not an integer or "line_items" is not a list.
-    """
-    if data is None:
-        raise ValueError("Request body is missing.")
-    if "line_items" not in data:
-        raise ValueError("Missing 'line_items' field.")
-    if "discount" not in data:
-        raise ValueError("Missing 'discount' field.")
-    if type(data["discount"]) is not int:
-        raise TypeError("'discount' must be an int.")
-    if type(data["line_items"]) is not list:
-        raise TypeError("'line_items' must be a list.")
-    if len(data["line_items"]) < 1:
-        raise ValueError("Request must include at least one line item.")
\ No newline at end of file
+        Args:
+            product_id (int): The unique identifier of the product.
+        Returns:
+            dict: The product details containing "name" and "price".
+        Raises:
+            ValueError: If no product with the given ID is found.
+        """
+        product = self.db.session.get(self.Product, product_id)
+        if not product:
+            raise ValueError(f"Product with id {product_id} not found.")
+        return {"name" : product.name, "price" : product.price}
+        
+    def valid_sales_request(self, data: dict):
+        """
+        Validate the sales request data to ensure all required fields are present
+        and of the correct type.
+
+        Args:
+            data (dict): The sales request data which must include:
+                - "line_items": A list of line items.
+                - "discount": An integer representing the discount amount.
+        Raises:
+            ValueError: If required fields are missing or if the list of line items is empty.
+            TypeError: If "discount" is not an integer or "line_items" is not a list.
+        """
+        if data is None:
+            raise ValueError("Request body is missing.")
+        if "line_items" not in data:
+            raise ValueError("Missing 'line_items' field.")
+        if "discount" not in data:
+            raise ValueError("Missing 'discount' field.")
+        if type(data["discount"]) is not int:
+            raise TypeError("'discount' must be an int.")
+        if type(data["line_items"]) is not list:
+            raise TypeError("'line_items' must be a list.")
+        if len(data["line_items"]) < 1:
+            raise ValueError("Request must include at least one line item.")
\ No newline at end of file
diff --git a/src/server.py b/src/server.py
index da03867..35fd36c 100644
--- a/src/server.py
+++ b/src/server.py
@@ -1,22 +1,43 @@
 from flask import Flask
 from dotenv import load_dotenv
 import os
-from db import init_db
-from products import products_bp
-from sales import sales_bp
+from db import init_db, db, Product
+from products import products_bp, ProductService
+from sales import sales_bp, SalesService
 
+class AppFactory:
+    # Constructor that initializes the Flask application, connects to the db, initializes services, and registers blueprints
+    def __init__(self, basedir: str = None):
+        # Sets basedir to be the absolute path of the directory containing this file, IF not provided
+        basedir = basedir if basedir else os.path.abspath(os.path.dirname(__file__))
+        self.app = Flask(__name__)# Instantiate the Flask application
+        self.__connect_db(basedir)# Calls the class function to connect to the db, with the basedir
+        self.__init_services()# Calls the class function to initialize the services
+        self.__register_blueprints()# Calls the class function to register the blueprints
 
-basedir = os.path.abspath(os.path.dirname(__file__)) # Store absolute path to current directory
-load_dotenv() # Load variables from .env file into the environment
-app = Flask(__name__) # Instantiate the Flask application
+    # Function to connect to the db
+    def __connect_db(self, basedir):
+        # Configure the db named 'catalog.db' to be stored in the base directory, and avoid SQLAlchemy from tracking modifications.
+        self.app.config['SQLALCHEMY_DATABASE_URI'] = f"sqlite:///{os.path.join(basedir, 'catalog.db')}"
+        self.app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
+        init_db(self.app)# Initialize the db to be populated with default data
+        self.db = db # Store the db instance in the app
 
-# Configure the db named 'catalog.db' to be stored in the base directory, and avoid SQLAlchemy from tracking modifications.
-app.config['SQLALCHEMY_DATABASE_URI'] = f"sqlite:///{os.path.join(basedir, 'catalog.db')}" 
-app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
-init_db(app) # Initialize the db to be populated with default data
+    # Function to initialize the services
+    def __init_services(self):
+        self.app.products_service = ProductService(db, Product)# Initialize the products service
+        self.app.sales_service = SalesService(db, Product)# Initialize the sales service
+    
+    # Function to register the blueprints
+    def __register_blueprints(self):
+        self.app.register_blueprint(products_bp)# Register the products blueprint with the application
+        self.app.register_blueprint(sales_bp)# Register the sales blueprint with the application
 
-app.register_blueprint(products_bp) # Register the products blueprint with the application
-app.register_blueprint(sales_bp) # Register the sales blueprint with the application
+# Function to create the app using the AppFactory, and return it
+def create_app():
+    return AppFactory().app
 
 if __name__ == "__main__":
-    app.run()
\ No newline at end of file
+    load_dotenv() # Load variables from .env file into the environment
+    app = create_app()# Create the app
+    app.run()# Run the app
\ No newline at end of file
diff --git a/testing/__init__.py b/testing/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/testing/test_server.py b/testing/test_server.py
new file mode 100644
index 0000000..e531215
--- /dev/null
+++ b/testing/test_server.py
@@ -0,0 +1,69 @@
+import pytest
+from src.server import AppFactory
+import os
+
+@pytest.fixture
+def app():
+    basedir = os.path.abspath(os.path.dirname(__file__)) # Store absolute path to current directory
+    test_app = AppFactory(basedir)
+    return test_app
+
+# Pytest fixture to create and yield a test client
+# This client simulates HTTP requests during tests.
+@pytest.fixture
+def client(app):
+    with app.app.test_client() as client:
+        yield client
+        app.db.session.remove()
+        app.db.drop_all()
+
+# Integration test for GET /products endpoint
+def test_get_products(client):
+    response = client.get('/products')
+    assert response.status_code == 200 # Assuring response code is HTTP 200
+    payload = response.get_json()
+    assert type(payload) is list # Assuring the payload type is a list
+    assert len(payload) > 0 # Assuring non-empty payload
+    assert all("id" in p and "name" in p and "price" in p for p in payload) # Assuring each product has id, name, and price fields
+
+# Integration test for POST /products endpoint
+def test_create_product(client):
+    mock_data = {"name": "Microwave", "price": 200} # Preparing mock request data
+    response = client.post('/products', json=mock_data)
+    assert response.status_code == 201 # Assuring response code is HTTP 201
+    data = response.get_json() 
+    assert "id" in data # Assuring response payload contains id field
+    assert data["name"] == mock_data["name"] # Assuring that the returned product's name matches that of the mock
+    assert data["price"] == mock_data["price"] # Assuring that the returned product's price matches that of the mock
+
+# Integration test for POST /sales endpoint
+def test_make_sale(client):
+    # Prepare a sale payload with two line items and a flat discount
+    sale_payload = {
+        "line_items": [
+            {"id": 1, "quantity": 2},
+            {"id": 2, "quantity": 1} 
+        ],
+        "discount": 10  # A flat discount to be distributed among line items
+    }
+    response = client.post('/sales', json=sale_payload)
+    assert response.status_code == 200
+    data = response.get_json()
+    
+    # Check that the response contains the expected keys
+    assert "line_items" in data
+    assert "total_sale_price" in data
+    
+    # Verify that each processed line item includes a discount value
+    for item in data["line_items"]:
+        assert "id" in item
+        assert "quantity" in item
+        assert "price" in item
+        assert "discount" in item and item["discount"] == 10/len(data["line_items"])
+
+    # - For product id=1: 2 * 100 = 200
+    # - For product id=2: 1 * 49.99 = 49.99
+    # The total_sale_price should be the sum of these (discount isn't subtracted from total_sale_price)
+    expected_total = 200 + 49.99
+    # Use a tolerance for floating point arithmetic
+    assert data["total_sale_price"] - expected_total == 0
\ No newline at end of file
